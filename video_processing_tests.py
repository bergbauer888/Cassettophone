import os
import unittest
import json
from math import floor
import shutil

from generators import generate_brainrot_clip, generate_lines_map, generate_subtitle
from assets_params import characters_map
from utils import remove_non_alphabetic
from video_utils import (
    snip_video,
    get_mediafile_duration,
    get_position,
    compute_avatars_overlay_filter,
    compose_ffmpeg_command,
    convert_subtitle_file,
)


class BrainrotTests(unittest.TestCase):
    script = """
        {
      "transcript": [
        {
          "agentId": "Joe Biden",
          "text": "Folks, Python is like a snake that codes itself. It's simple, powerful, and can handle any job with style."
        },
        {
          "agentId": "Joe Biden",
          "text": "Don't you worry about getting tangled in complexity, Python will slither through your code like a pro!"
        }
      ],
      "summary": ["Python programming language"]
    }
        """

    lines_file_path = "test_utils/lines_map.json"
    video_path = "backdrop/minecraft.mp4"
    output_snipped_video_path = "test_utils/snipped_video.mp4"
    output_file_path = "test_utils/output_video.mp4"
    ass_subtitle_path = "test_utils/subtitle.ass"
    srt_subtitle_path = "test_utils/subtitles/transcript.srt"
    backdrop_path = "test_utils/backdrop.mp4"
    lines_map_template_path = "test_utils/lines_map_test_base.json"
    resized_summary_path = ["test_utils/resized_summary.png"]
    resized_avatar_paths = ["test_utils/resized_joe_biden.png"]
    agent_ids = ["joe_biden"]
    asset_paths = [
        backdrop_path,
        *resized_summary_path,
        *resized_avatar_paths,
        ass_subtitle_path,
    ]

    # def test_snip_video(self):
    #     if os.path.exists(self.output_snipped_video_path):
    #         os.remove(self.output_snipped_video_path)

    #     snip_video(self.video_path, 10, self.output_snipped_video_path)

    #     self.assertTrue(os.path.exists(self.output_snipped_video_path))
    #     self.assertEqual(
    #         floor(get_mediafile_duration(self.output_snipped_video_path)), 10
    #     )

    def test_generate_lines_file(self):
        test_lines_map_path = "test_utils/lines_map_unit_test.json"
        if os.path.exists(test_lines_map_path):
            os.remove(test_lines_map_path)
        shutil.copyfile(self.lines_map_template_path, test_lines_map_path)
        with open("test_utils/langer_script.json") as json_data:
            generate_lines_map("".join(json_data.readlines()), test_lines_map_path)

    # def test_compute_avatars_overlay(self):
    #     expected_output = "[0:v][1:v]overlay=W-w-300:H-h-0:enable='between(t,0,7)'[v0],[v0][1:v]overlay=W-w-10:H-h-0:enable='between(t,7,13)'[v1]"
    #     with open(self.lines_file_path, "r") as json_data:
    #         lines_data = json.load(json_data)
    #     result_overlay = compute_avatars_overlay_filter(["joe_biden"], lines_data)

    #     self.assertEqual(result_overlay, expected_output)

    # def test_generate_brainrot_clip_with_valid_inputs(self):
    #     if os.path.exists(self.output_file_path):
    #         os.remove(self.output_file_path)

    #     generate_brainrot_clip(
    #         self.asset_paths,
    #         self.lines_file_path,
    #         self.agent_ids,
    #         self.resized_summary_path,
    #         self.ass_subtitle_path,
    #         self.output_file_path,
    #     )

    #     # not many asserts i can do, just visually inspect the video
    #     duration_output = floor(get_mediafile_duration(self.output_file_path))
    #     duration_backdrop = floor(get_mediafile_duration(self.backdrop_path))

    #     assert os.path.exists(self.output_file_path)
    #     assert (
    #         abs(duration_output - duration_backdrop) <= 3
    #     ), f"Durations differ by more than 3: {duration_output} vs {duration_backdrop}"

    # def test_convert_subtitle_file(self):
    #     output_subtitle_path = "test_utils/test_subtitle.ass"
    #     expected_output = """['[Script Info]\n', '; Script generated by FFmpeg/Lavc61.19.101\n', 'ScriptType: v4.00+\n', 'PlayResX: 384\n', 'PlayResY: 288\n', 'ScaledBorderAndShadow: yes\n', 'YCbCr Matrix: None\n', '\n', '[V4+ Styles]\n', 'Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n', 'Style: Default,Wiener Melange,18,&H0099ff,&Hffffff,&H0,&H0,1,0,0,0,100,100,0,0,1,1,2,5,50,50,50,1\n', '\n', '[Events]\n', 'Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n', "Dialogue: 0,0:00:00.70,0:00:01.42,Default,,0,0,0,,{\\c&HFF00&}Folks,{\\c} Python's like\n", "Dialogue: 0,0:00:01.42,0:00:01.90,Default,,0,0,0,,Folks, {\\c&HFF00&}Python's{\\c} like\n", "Dialogue: 0,0:00:01.90,0:00:02.08,Default,,0,0,0,,Folks, Python's {\\c&HFF00&}like{\\c}\n", 'Dialogue: 0,0:00:02.08,0:00:02.18,Default,,0,0,0,,{\\c&HFF00&}a{\\c} snake that\n', 'Dialogue: 0,0:00:02.18,0:00:02.50,Default,,0,0,0,,a {\\c&HFF00&}snake{\\c} that\n', 'Dialogue: 0,0:00:02.50,0:00:02.76,Default,,0,0,0,,a snake {\\c&HFF00&}that{\\c}\n', 'Dialogue: 0,0:00:02.76,0:00:02.98,Default,,0,0,0,,{\\c&HFF00&}codes{\\c} itself.\n', 'Dialogue: 0,0:00:02.98,0:00:04.20,Default,,0,0,0,,codes {\\c&HFF00&}itself.{\\c}\n', "Dialogue: 0,0:00:04.20,0:00:04.38,Default,,0,0,0,,{\\c&HFF00&}It's{\\c} simple,\n", "Dialogue: 0,0:00:04.38,0:00:04.84,Default,,0,0,0,,It's {\\c&HFF00&}simple,{\\c}\n", 'Dialogue: 0,0:00:04.84,0:00:05.30,Default,,0,0,0,,{\\c&HFF00&}powerful,{\\c}\n', 'Dialogue: 0,0:00:05.30,0:00:05.48,Default,,0,0,0,,{\\c&HFF00&}and{\\c} can handle\n', 'Dialogue: 0,0:00:05.48,0:00:05.64,Default,,0,0,0,,and {\\c&HFF00&}can{\\c} handle\n', 'Dialogue: 0,0:00:05.64,0:00:05.92,Default,,0,0,0,,and can {\\c&HFF00&}handle{\\c}\n', 'Dialogue: 0,0:00:05.92,0:00:06.10,Default,,0,0,0,,{\\c&HFF00&}any{\\c} job with\n', 'Dialogue: 0,0:00:06.10,0:00:06.54,Default,,0,0,0,,any {\\c&HFF00&}job{\\c} with\n', 'Dialogue: 0,0:00:06.54,0:00:06.64,Default,,0,0,0,,any job {\\c&HFF00&}with{\\c}\n', 'Dialogue: 0,0:00:06.64,0:00:07.68,Default,,0,0,0,,{\\c&HFF00&}style.{\\c}\n', "Dialogue: 0,0:00:07.68,0:00:07.92,Default,,0,0,0,,{\\c&HFF00&}Don't{\\c} you worry\n", "Dialogue: 0,0:00:07.92,0:00:08.00,Default,,0,0,0,,Don't {\\c&HFF00&}you{\\c} worry\n", "Dialogue: 0,0:00:08.00,0:00:08.24,Default,,0,0,0,,Don't you {\\c&HFF00&}worry{\\c}\n", 'Dialogue: 0,0:00:08.24,0:00:08.46,Default,,0,0,0,,{\\c&HFF00&}about{\\c} getting tangled\n', 'Dialogue: 0,0:00:08.46,0:00:08.72,Default,,0,0,0,,about {\\c&HFF00&}getting{\\c} tangled\n', 'Dialogue: 0,0:00:08.72,0:00:09.18,Default,,0,0,0,,about getting {\\c&HFF00&}tangled{\\c}\n', 'Dialogue: 0,0:00:09.18,0:00:09.40,Default,,0,0,0,,{\\c&HFF00&}in{\\c} complexity.\n', 'Dialogue: 0,0:00:09.40,0:00:10.44,Default,,0,0,0,,in {\\c&HFF00&}complexity.{\\c}\n', 'Dialogue: 0,0:00:10.44,0:00:10.74,Default,,0,0,0,,{\\c&HFF00&}Python{\\c} will slither\n', 'Dialogue: 0,0:00:10.74,0:00:11.12,Default,,0,0,0,,Python {\\c&HFF00&}will{\\c} slither\n', 'Dialogue: 0,0:00:11.12,0:00:11.62,Default,,0,0,0,,Python will {\\c&HFF00&}slither{\\c}\n', 'Dialogue: 0,0:00:11.62,0:00:11.82,Default,,0,0,0,,{\\c&HFF00&}through{\\c} your code\n', 'Dialogue: 0,0:00:11.82,0:00:12.28,Default,,0,0,0,,through {\\c&HFF00&}your{\\c} code\n', 'Dialogue: 0,0:00:12.28,0:00:12.56,Default,,0,0,0,,through your {\\c&HFF00&}code{\\c}\n', 'Dialogue: 0,0:00:12.56,0:00:13.16,Default,,0,0,0,,{\\c&HFF00&}like{\\c} a pro.\n', 'Dialogue: 0,0:00:13.16,0:00:13.32,Default,,0,0,0,,like {\\c&HFF00&}a{\\c} pro.\n', 'Dialogue: 0,0:00:13.32,0:00:13.58,Default,,0,0,0,,like a {\\c&HFF00&}pro.{\\c}\n']"""
    #     if os.path.exists(output_subtitle_path):
    #         os.remove(output_subtitle_path)

    #     convert_subtitle_file(
    #         self.srt_subtitle_path, "Wiener Melange", output_subtitle_path
    #     )

    #     with open(output_subtitle_path, "r") as outfile:
    #         self.assertEqual(
    #             remove_non_alphabetic("".join(outfile.readlines())),
    #             remove_non_alphabetic(expected_output.strip()),
    #         )

    # def test_generate_subtitle_test(self):
    #     test_subtitle_path = "test_utils/subtitles/transcript_test.srt"
    #     test_lines_map = "test_utils/lines_map_test.json"
    #     if os.path.exists(test_subtitle_path):
    #         os.remove(test_subtitle_path)
    #     if os.path.exists(test_lines_map):
    #         os.remove(test_lines_map)
    #     subtitle_expected_output = """
    #     ['1\n', '00:00:00,700 --> 00:00:01,420\n', '<font color="#00ff00">Folks,</font> Python\'s like\n', ' 3\n',
    #     '00:00:01,420 --> 00:00:01,900\n', 'Folks, <font color="#00ff00">Python\'s</font> like\n', ' 4\n',
    #     '00:00:01,900 --> 00:00:02,080\n', 'Folks, Python\'s <font color="#00ff00">like</font>\n', ' 6\n',
    #     '00:00:02,080 --> 00:00:02,180\n', '<font color="#00ff00">a</font> snake that\n', ' 7\n',
    #     '00:00:02,180 --> 00:00:02,500\n', 'a <font color="#00ff00">snake</font> that\n', ' 8\n',
    #     '00:00:02,500 --> 00:00:02,760\n', 'a snake <font color="#00ff00">that</font>\n', ' 10\n',
    #     '00:00:02,760 --> 00:00:02,980\n', '<font color="#00ff00">codes</font> itself.\n', ' 11\n',
    #     '00:00:02,980 --> 00:00:04,200\n', 'codes <font color="#00ff00">itself.</font>\n', ' 12\n',
    #     '00:00:04,200 --> 00:00:04,380\n', '<font color="#00ff00">It\'s</font> simple,\n', ' 13\n',
    #     '00:00:04,380 --> 00:00:04,840\n', 'It\'s <font color="#00ff00">simple,</font>\n', ' 14\n',
    #     '00:00:04,840 --> 00:00:05,300\n', '<font color="#00ff00">powerful,</font>\n', ' 15\n',
    #     '00:00:05,300 --> 00:00:05,480\n', '<font color="#00ff00">and</font> can handle\n', ' 16\n',
    #     '00:00:05,480 --> 00:00:05,640\n', 'and <font color="#00ff00">can</font> handle\n', ' 18\n',
    #     '00:00:05,640 --> 00:00:05,920\n', 'and can <font color="#00ff00">handle</font>\n', ' 19\n',
    #     '00:00:05,920 --> 00:00:06,100\n', '<font color="#00ff00">any</font> job with\n', ' 20\n',
    #     '00:00:06,100 --> 00:00:06,540\n', 'any <font color="#00ff00">job</font> with\n', ' 22\n',
    #     '00:00:06,540 --> 00:00:06,640\n', 'any job <font color="#00ff00">with</font>\n', ' 23\n',
    #     '00:00:06,640 --> 00:00:07,680\n', '<font color="#00ff00">style.</font>\n', ' 24\n',
    #     '00:00:07,680 --> 00:00:07,920\n', '<font color="#00ff00">Don\'t</font> you worry\n', ' 25\n',
    #     '00:00:07,920 --> 00:00:08,000\n', 'Don\'t <font color="#00ff00">you</font> worry\n', ' 26\n',
    #     '00:00:08,000 --> 00:00:08,240\n', 'Don\'t you <font color="#00ff00">worry</font>\n', ' 27\n',
    #     '00:00:08,240 --> 00:00:08,460\n', '<font color="#00ff00">about</font> getting tangled\n', ' 28\n',
    #     '00:00:08,460 --> 00:00:08,720\n', 'about <font color="#00ff00">getting</font> tangled\n', ' 29\n',
    #     '00:00:08,720 --> 00:00:09,180\n', 'about getting <font color="#00ff00">tangled</font>\n', ' 30\n',
    #     '00:00:09,180 --> 00:00:09,400\n', '<font color="#00ff00">in</font> complexity.\n', ' 31\n',
    #     '00:00:09,400 --> 00:00:10,440\n', 'in <font color="#00ff00">complexity.</font>\n', ' 32\n',
    #     '00:00:10,440 --> 00:00:10,740\n', '<font color="#00ff00">Python</font> will slither\n', ' 33\n',
    #     '00:00:10,740 --> 00:00:11,120\n', 'Python <font color="#00ff00">will</font> slither\n', ' 34\n',
    #     '00:00:11,120 --> 00:00:11,620\n', 'Python will <font color="#00ff00">slither</font>\n', ' 35\n',
    #     '00:00:11,620 --> 00:00:11,820\n', '<font color="#00ff00">through</font> your code\n', ' 36\n',
    #     '00:00:11,820 --> 00:00:12,280\n', 'through <font color="#00ff00">your</font> code\n', ' 38\n',
    #     '00:00:12,280 --> 00:00:12,560\n', 'through your <font color="#00ff00">code</font>\n', ' 39\n',
    #     '00:00:12,560 --> 00:00:13,160\n', '<font color="#00ff00">like</font> a pro.\n', ' 40\n',
    #     '00:00:13,160 --> 00:00:13,320\n', 'like <font color="#00ff00">a</font> pro.\n', ' 41\n',
    #     '00:00:13,320 --> 00:00:13,580\n', 'like a <font color="#00ff00">pro.</font>']
    #     """
    #     lines_map_expected_output = """
    #     1
    # 0:00:00,700000 --> 0:00:03,420000
    # Folks, Python's like a snake that codes itself.

    # 2
    # 0:00:04,200000 --> 0:00:04,720000
    # It's simple,

    # 3
    # 0:00:04,840000 --> 0:00:05,180000
    # powerful,

    # 4
    # 0:00:05,300000 --> 0:00:07,060000
    # and can handle any job with style.

    # 5
    # 0:00:07,680000 --> 0:00:09,980000
    # Don't you worry about getting tangled in complexity.

    # 6
    # 0:00:10,440000 --> 0:00:13,580000
    # Python will slither through your code like a pro.
    #     """
    #     generate_subtitle(
    #         "test_utils/samples/video_audio.wav", "word", test_subtitle_path, test_lines_map
    #     )
    #     with open(test_subtitle_path, "r") as outfile:
    #         assert outfile.readlines().__eq__(subtitle_expected_output)

    #     with open(test_lines_map, "r") as outfile:
    #         assert outfile.readlines().__eq__(lines_map_expected_output)


# def test_generate_brainrot_clip_does_not_throw_error_when_summary_is_invalid():
#     lines_map_path = "test_utils/lines_map.json"
#     output_folder = "test_utils/"
#     output_file_path = f"{output_folder}/output_video.mp4"
#     asset_paths = [
#         "test_utils/backdrop.mp4",
#         None,
#         "test_utils/resized_joe_biden.png",
#         "test_utils/resized_donald_trump.png",
#     ]

#     generate_brainrot_clip(
#         asset_paths,
#         lines_map_path,
#         output_file_path,
#     )

#     # not many asserts i can do, just visually inspect the video
#     duration_output = floor(get_mediafile_duration(output_file_path))
#     duration_backdrop = floor(get_mediafile_duration(f"{output_folder}/backdrop.mp4"))

#     assert os.path.exists(output_file_path)
#     assert (
#         abs(duration_output - duration_backdrop) <= 3
#     ), f"Durations differ by more than 3: {duration_output} vs {duration_backdrop}"


# def test_compose_ffmpeg_command():
#     output_folder = "test_utils/"
#     output_file_path = f"{output_folder}/output_video.mp4"
#     input_chain = [
#         "test_utils/backdrop.mp4",
#         "test_utils/resized_summary.png",
#         "test_utils/resized_joe_biden.png",
#         "test_utils/resized_donald_trump.png",
#     ]
#     filter_string = "[0:v][1:v]overlay=(W-w)/2:10:enable='between(t,0,13)'[v0-13],[v0-13][2:v]overlay=W-w-10:H-h-0:enable='between(t,1,12)'[v1-12],[v1-12][3:v]overlay=W-w-250:H-h-0:enable='between(t,13,18)'[v13-18]"
#     expected_string = remove_non_alphabetic(
#         "['ffmpeg', '-i', 'test_utils/backdrop.mp4', '-i', 'test_utils/resized_summary.png', '-i', 'test_utils/resized_joe_biden.png', '-i', 'test_utils/resized_donald_trump.png', '-filter_complex', \"[0:v][1:v]overlay=(W-w)/2:10:enable='between(t,0,13)'[v0-13],[v0-13][2:v]overlay=W-w-10:H-h-0:enable='between(t,1,12)'[v1-12],[v1-12][3:v]overlay=W-w-250:H-h-0:enable='between(t,13,18)'[v13-18]\", '-map', '[v13-18]', '-c:a', 'copy', 'test_utils//output_video.mp4']"
#     )

#     command = remove_non_alphabetic(
#         "".join(compose_ffmpeg_command(input_chain, filter_string, output_file_path))
#     )

#     assert command == expected_string


# test_snip_video()
# test_generate_brainrot_clip_with_valid_inputs()
# test_generate_brainrot_clip_does_not_throw_error_when_summary_is_invalid()
# test_compose_ffmpeg_command()
# generate_subtitle_test()

if __name__ == "__main__":
    unittest.main()
# def pwla():
#     test_subtitle_path = "test_utils/subtitles/transcript_test.srt"
#     test_lines_map = "test_utils/lines_map_test.json"
#     if os.path.exists(test_subtitle_path):
#         os.remove(test_subtitle_path)
#     if os.path.exists(test_lines_map):
#         os.remove(test_lines_map)
#     generate_subtitle(
#             "culala/samples/video_audio.wav", "word", test_subtitle_path, test_lines_map
#     )
# pwla()
